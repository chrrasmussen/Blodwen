module ErlangPrelude

namespace Idris
  public export
  data Raw a = MkRaw a


namespace Opaque
  public export
  data ErlTerm : Type where

  public export
  data ErlPid : Type where

  public export
  data ErlRef : Type where

  public export
  data ErlPort : Type where


mutual
  public export
  data ErlType : Type -> Type where
    ETInt       : ErlType Int
    ETInteger   : ErlType Integer
    ETString    : ErlType String
    ETChar      : ErlType Char
    ETDouble    : ErlType Double
    ETUnit      : ErlType ()
    ETList      : ErlType a => ErlType (List a)

    ETRaw       : ErlType (Raw a)     -- Can contain any Idris value
    ETErlTerm   : ErlType ErlTerm     -- Can contain any Erlang term

    -- Data types that bridge to native Erlang data types
    ETErlList   : (ErlType x, ErlType (ErlList xs)) => ErlType (ErlList (x :: xs))
    ETErlTuple0 : ErlType ErlTuple0
    ETErlTuple1 : ErlType a => ErlType (ErlTuple1 a)
    ETErlTuple2 : (ErlType a, ErlType b) => ErlType (ErlTuple2 a b)
    ETErlTuple3 : (ErlType a, ErlType b, ErlType c) => ErlType (ErlTuple3 a b c)
    ETErlTuple4 : (ErlType a, ErlType b, ErlType c, ErlType d) => ErlType (ErlTuple4 a b c d)
    ETErlTuple5 : (ErlType a, ErlType b, ErlType c, ErlType d, ErlType e) => ErlType (ErlTuple5 a b c d e)
    ETErlMap    : ErlType ErlMap
    ETErlPid    : ErlType ErlPid
    ETErlRef    : ErlType ErlRef
    ETErlPort   : ErlType ErlPort


  namespace Lists
    public export
    data ErlList : List Type -> Type where
      Nil : ErlList []
      (::) : x -> ErlList xs -> ErlList (x :: xs)


  namespace Tuples
    public export
    data ErlTuple0 : Type where
      MkErlTuple0 : ErlTuple0

    public export
    data ErlTuple1 : Type -> Type where
      MkErlTuple1 : a -> ErlTuple1 a

    public export
    data ErlTuple2 : Type -> Type -> Type where
      MkErlTuple2 : a -> b -> ErlTuple2 a b

    public export
    data ErlTuple3 : Type -> Type -> Type -> Type where
      MkErlTuple3 : a -> b -> c ->  ErlTuple3 a b c

    public export
    data ErlTuple4 : Type -> Type -> Type -> Type -> Type where
      MkErlTuple4 : a -> b -> c -> d -> ErlTuple4 a b c d

    public export
    data ErlTuple5 : Type -> Type -> Type -> Type -> Type -> Type where
      MkErlTuple5 : a -> b -> c -> d -> e -> ErlTuple5 a b c d e


  namespace Maps
    export
    data ErlMapKeyValue : Type where
      MkKeyValue : key -> value -> ErlMapKeyValue

    -- TODO: Which priority?
    infix 3 :=

    export
    (:=) : key -> value -> ErlMapKeyValue
    (:=) = MkKeyValue

    export
    data ErlMap : Type where
      ErlMapNil : ErlMap
      ErlMapCons : ErlMapKeyValue -> ErlMap -> ErlMap

    export
    Nil : ErlMap
    Nil = ErlMapNil

    export
    (::) : ErlMapKeyValue -> ErlMap -> ErlMap
    (::) = ErlMapCons

    export
    unsafeGet : (ret : Type) -> {auto prf : ErlType ret} -> key -> ErlMap -> IO ret
    unsafeGet ret key m = erlangCall ret "maps:get" [key, m]


  namespace IO
    %extern prim__erlangCall : (ret : Type) -> String -> ErlList xs -> (1 x : %World) -> IORes ret

    export %inline
    erlangCall : (ret : Type) -> {auto prf : ErlType ret} -> String -> ErlList xs -> IO ret
    erlangCall ret fn args = primIO (prim__erlangCall ret fn args)


----------
-- CAST --
----------

-- TODO: Is `believe_me x` a better solution?
toErlTerm : ErlType a => a -> ErlTerm
toErlTerm x = unsafePerformIO $ erlangCall ErlTerm "blodwen_id" [x]

-- Allow all supported Erlang types to be type erased
ErlType a => Cast a ErlTerm where
  cast x = toErlTerm x


Cast () ErlTuple0 where
  cast MkUnit = MkErlTuple0

Cast ErlTuple0 () where
  cast MkErlTuple0 = MkUnit


ErlType a => Cast (List a) (ErlList []) where
  cast [] = []

(ErlType a, Cast (List a) (ErlList as)) => Cast (List a) (ErlList (a :: as)) where
  cast (x :: xs) = (x :: cast xs)


----------
-- SHOW --
----------

showSep : String -> List String -> String
showSep sep [] = ""
showSep sep [x] = x
showSep sep (x :: xs) = x ++ sep ++ showSep sep xs


-- OPAQUE ERLANG TYPES
-- (Idris should not know its content)

Show ErlTerm where
  show _ = "<Erlang Term>"

Show ErlPid where
  show _ = "<Erlang Pid>"

Show ErlRef where
  show _ = "<Erlang Ref>"

Show ErlPort where
  show _ = "<Erlang Port>"


-- NORMAL ERLANG TYPES

Show (ErlList []) where
  show [] = "[]"

(Show x, Show (ErlList xs)) => Show (ErlList (x :: xs)) where
  show (x :: xs) = "[" ++ show x ++ " | " ++ show xs ++ "]"

Show ErlTuple0 where
  show MkErlTuple0 = "{}"

Show a => Show (ErlTuple1 a) where
  show (MkErlTuple1 x1) =
    "{" ++ showSep ", " [show x1] ++ "}"

(Show a, Show b) => Show (ErlTuple2 a b) where
  show (MkErlTuple2 x1 x2) =
    "{" ++ showSep ", " [show x1, show x2] ++ "}"

(Show a, Show b, Show c) => Show (ErlTuple3 a b c) where
  show (MkErlTuple3 x1 x2 x3) =
    "{" ++ showSep ", " [show x1, show x2, show x3] ++ "}"

(Show a, Show b, Show c, Show d) => Show (ErlTuple4 a b c d) where
  show (MkErlTuple4 x1 x2 x3 x4) =
    "{" ++ showSep ", " [show x1, show x2, show x3, show x4] ++ "}"

(Show a, Show b, Show c, Show d, Show e) => Show (ErlTuple5 a b c d e) where
  show (MkErlTuple5 x1 x2 x3 x4 x5) =
    "{" ++ showSep ", " [show x1, show x2, show x3, show x4, show x5] ++ "}"

Show ErlMap where
  show _ = "<Erlang Map>" -- TODO: Implement
