module ErlangPrelude


namespace Atoms
  public export
  data ErlAtom : Type where
    MkErlAtom : String -> ErlAtom


namespace Lists
  public export
  data ErlList : List Type -> Type where
    Nil : ErlList []
    (::) : x -> ErlList xs -> ErlList (x :: xs)


namespace Tuples
  public export
  data ErlTuple0 : Type where
    MkErlTuple0 : ErlTuple0

  public export
  data ErlTuple1 : Type -> Type where
    MkErlTuple1 : a -> ErlTuple1 a

  public export
  data ErlTuple2 : Type -> Type -> Type where
    MkErlTuple2 : a -> b -> ErlTuple2 a b

  public export
  data ErlTuple3 : Type -> Type -> Type -> Type where
    MkErlTuple3 : a -> b -> c ->  ErlTuple3 a b c

  public export
  data ErlTuple4 : Type -> Type -> Type -> Type -> Type where
    MkErlTuple4 : a -> b -> c -> d -> ErlTuple4 a b c d

  public export
  data ErlTuple5 : Type -> Type -> Type -> Type -> Type -> Type where
    MkErlTuple5 : a -> b -> c -> d -> e -> ErlTuple5 a b c d e


namespace Functions
  public export
  data ErlFun0 : Type -> Type where
    MkErlFun0 : ret -> ErlFun0 ret

  public export
  data ErlFun1 : Type -> Type -> Type where
    MkErlFun1 : (a -> ret) -> ErlFun1 a ret

  public export
  data ErlFun2 : Type -> Type -> Type -> Type where
    MkErlFun2 : (a -> b -> ret) -> ErlFun2 a b ret

  public export
  data ErlFun3 : Type -> Type -> Type -> Type -> Type where
    MkErlFun3 : (a -> b -> c -> ret) -> ErlFun3 a b c ret

  public export
  data ErlFun4 : Type -> Type -> Type -> Type -> Type -> Type where
    MkErlFun4 : (a -> b -> c -> d -> ret) -> ErlFun4 a b c d ret

  public export
  data ErlFun5 : Type -> Type -> Type -> Type -> Type -> Type -> Type where
    MkErlFun5 : (a -> b -> c -> d -> e -> ret) -> ErlFun5 a b c d e ret

  public export
  data ErlIO0 : Type -> Type where
    MkErlIO0  : IO ret -> ErlIO0 ret

  public export
  data ErlIO1 : Type -> Type -> Type where
    MkErlIO1  : (a -> IO ret) -> ErlIO1 a ret

  public export
  data ErlIO2 : Type -> Type -> Type -> Type where
    MkErlIO2  : (a -> b -> IO ret) -> ErlIO2 a b ret

  public export
  data ErlIO3 : Type -> Type -> Type -> Type -> Type where
    MkErlIO3  : (a -> b -> c -> IO ret) -> ErlIO3 a b c ret

  public export
  data ErlIO4 : Type -> Type -> Type -> Type -> Type -> Type where
    MkErlIO4  : (a -> b -> c -> d -> IO ret) -> ErlIO4 a b c d ret

  public export
  data ErlIO5 : Type -> Type -> Type -> Type -> Type -> Type -> Type where
    MkErlIO5  : (a -> b -> c -> d -> e -> IO ret) -> ErlIO5 a b c d e ret


namespace Idris
  public export
  data Raw a = MkRaw a


namespace Opaque
  public export
  data ErlTerm : Type where

  public export
  data ErlMap : Type where

  public export
  data ErlPid : Type where

  public export
  data ErlRef : Type where

  public export
  data ErlPort : Type where


mutual
  public export
  data ErlType : Type -> Type where
    ETInt           : ErlType Int
    ETInteger       : ErlType Integer
    ETString        : ErlType String
    ETChar          : ErlType Char
    ETDouble        : ErlType Double

    ETUnit          : ErlType ()
    ETBool          : ErlType Bool
    ETList          : ErlType a => ErlType (List a)
    ETFun           : (ErlType a, ErlType b) => ErlType (a -> b) -- NOTE: These functions are curried in Erlang as well

    ETRaw           : ErlType (Raw a)     -- Can contain any Idris value
    ETErlTerm       : ErlType ErlTerm     -- Can contain any Erlang term

    -- Data types that bridge to native Erlang data types
    ETErlAtom       : ErlType ErlAtom
    ETErlList       : ErlTypes xs => ErlType (ErlList xs)
    ETErlTuple0     : ErlType ErlTuple0
    ETErlTuple1     : ErlTypes [a] => ErlType (ErlTuple1 a)
    ETErlTuple2     : ErlTypes [a, b] => ErlType (ErlTuple2 a b)
    ETErlTuple3     : ErlTypes [a, b, c] => ErlType (ErlTuple3 a b c)
    ETErlTuple4     : ErlTypes [a, b, c, d] => ErlType (ErlTuple4 a b c d)
    ETErlTuple5     : ErlTypes [a, b, c, d, e] => ErlType (ErlTuple5 a b c d e)
    ETErlFun0       : ErlTypes [ret] => ErlType (ErlFun0 ret)
    ETErlFun1       : ErlTypes [a, ret] => ErlType (ErlFun1 a ret)
    ETErlFun2       : ErlTypes [a, b, ret] => ErlType (ErlFun2 a b ret)
    ETErlFun3       : ErlTypes [a, b, c, ret] => ErlType (ErlFun3 a b c ret)
    ETErlFun4       : ErlTypes [a, b, c, d, ret] => ErlType (ErlFun4 a b c d ret)
    ETErlFun5       : ErlTypes [a, b, c, d, e, ret] => ErlType (ErlFun5 a b c d e ret)
    ETErlIO0        : ErlTypes [ret] => ErlType (ErlIO0 ret)
    ETErlIO1        : ErlTypes [a, ret] => ErlType (ErlIO1 a ret)
    ETErlIO2        : ErlTypes [a, b, ret] => ErlType (ErlIO2 a b ret)
    ETErlIO3        : ErlTypes [a, b, c, ret] => ErlType (ErlIO3 a b c ret)
    ETErlIO4        : ErlTypes [a, b, c, d, ret] => ErlType (ErlIO4 a b c d ret)
    ETErlIO5        : ErlTypes [a, b, c, d, e, ret] => ErlType (ErlIO5 a b c d e ret)
    ETErlMap        : ErlType ErlMap
    ETErlPid        : ErlType ErlPid
    ETErlRef        : ErlType ErlRef
    ETErlPort       : ErlType ErlPort

  public export
  data ErlTypes : List Type -> Type where
    ETErlTypesNil   : ErlTypes []
    ETErlTypesCons  : (ErlType x, ErlTypes xs) => ErlTypes (x :: xs)


namespace CaseExpr
  public export
  data ErlMatcher : Type -> Type where
    MExact : ErlType a => a -> (a -> b) -> ErlMatcher b
    MAny : (ErlTerm -> a) -> ErlMatcher a
    MInteger : (Integer -> a) -> ErlMatcher a
    MString : (String -> a) -> ErlMatcher a
    MErlTuple0 : a -> ErlMatcher a
    MErlTuple1 : (a -> b) -> ErlMatcher a -> ErlMatcher b
    MErlTuple2 : (a -> b -> c) -> ErlMatcher a -> ErlMatcher b -> ErlMatcher c

  %extern
  export
  erlCase : a -> List (ErlMatcher a) -> ErlTerm -> a


namespace IO
  %extern prim__erlCall : (ret : Type) -> String -> ErlList xs -> (1 x : %World) -> IORes ret

  export %inline
  erlCall : (ret : Type) -> {auto ret_prf : ErlType ret} ->
            String ->
            ErlList xs -> {auto inp_prf : ErlTypes xs} ->
            IO ret
  erlCall ret fn args = primIO (prim__erlCall ret fn args)


----------
-- CAST --
----------

-- TODO: Is `believe_me x` a better solution?
toErlTerm : ErlType a => a -> ErlTerm
toErlTerm x = unsafePerformIO $ erlCall ErlTerm "blodwen_id" [x]

-- Allow all supported Erlang types to be type erased
ErlType a => Cast a ErlTerm where
  cast x = toErlTerm x


Cast () ErlTuple0 where
  cast MkUnit = MkErlTuple0

Cast ErlTuple0 () where
  cast MkErlTuple0 = MkUnit


Cast Bool ErlAtom where
  cast True = MkErlAtom "true"
  cast False = MkErlAtom "false"


ErlType a => Cast (List a) (ErlList []) where
  cast [] = []

(ErlType a, Cast (List a) (ErlList as)) => Cast (List a) (ErlList (a :: as)) where
  cast (x :: xs) = (x :: cast xs)


----------
-- SHOW --
----------

showSep : String -> List String -> String
showSep sep [] = ""
showSep sep [x] = x
showSep sep (x :: xs) = x ++ sep ++ showSep sep xs


-- OPAQUE ERLANG TYPES
-- (Idris should not know its content)

Show ErlTerm where
  show _ = "<Erlang Term>"

Show ErlPid where
  show _ = "<Erlang Pid>"

Show ErlRef where
  show _ = "<Erlang Ref>"

Show ErlPort where
  show _ = "<Erlang Port>"


-- NORMAL ERLANG TYPES

Show ErlAtom where
  show (MkErlAtom x) = "'" ++ x ++ "'"

Show (ErlList []) where
  show [] = "[]"

(Show x, Show (ErlList xs)) => Show (ErlList (x :: xs)) where
  show (x :: xs) = "[" ++ show x ++ " | " ++ show xs ++ "]"

Show ErlTuple0 where
  show MkErlTuple0 = "{}"

Show a => Show (ErlTuple1 a) where
  show (MkErlTuple1 x1) =
    "{" ++ showSep ", " [show x1] ++ "}"

(Show a, Show b) => Show (ErlTuple2 a b) where
  show (MkErlTuple2 x1 x2) =
    "{" ++ showSep ", " [show x1, show x2] ++ "}"

(Show a, Show b, Show c) => Show (ErlTuple3 a b c) where
  show (MkErlTuple3 x1 x2 x3) =
    "{" ++ showSep ", " [show x1, show x2, show x3] ++ "}"

(Show a, Show b, Show c, Show d) => Show (ErlTuple4 a b c d) where
  show (MkErlTuple4 x1 x2 x3 x4) =
    "{" ++ showSep ", " [show x1, show x2, show x3, show x4] ++ "}"

(Show a, Show b, Show c, Show d, Show e) => Show (ErlTuple5 a b c d e) where
  show (MkErlTuple5 x1 x2 x3 x4 x5) =
    "{" ++ showSep ", " [show x1, show x2, show x3, show x4, show x5] ++ "}"

Show ErlMap where
  show _ = "<Erlang Map>" -- TODO: Implement
