module ErlangPrelude


namespace Idris
  public export
  data Raw a = MkRaw a


namespace Atoms
  public export
  data ErlAtom = MkErlAtom String


namespace Strings
  public export
  data ErlBinary = MkErlBinary String

  public export
  data ErlCharlist = MkErlCharlist String


namespace Lists
  public export
  data ErlList : List Type -> Type where
    Nil : ErlList []
    (::) : x -> ErlList xs -> ErlList (x :: xs)


namespace Opaque
  export
  data ErlTerm : Type where

  export
  data ErlMap : Type where

  export
  data ErlPid : Type where

  export
  data ErlRef : Type where

  export
  data ErlPort : Type where


namespace Tuples
  public export
  data ErlTuple0 = MkErlTuple0

  public export
  data ErlTuple1 a = MkErlTuple1 a

  public export
  data ErlTuple2 a b = MkErlTuple2 a b

  public export
  data ErlTuple3 a b c = MkErlTuple3 a b c

  public export
  data ErlTuple4 a b c d = MkErlTuple4 a b c d

  public export
  data ErlTuple5 a b c d e = MkErlTuple5 a b c d e


namespace Functions
  public export
  data ErlFun0 : Type -> Type where
    MkErlFun0 : ret -> ErlFun0 ret

  public export
  data ErlFun1 : Type -> Type -> Type where
    MkErlFun1 : (a -> ret) -> ErlFun1 a ret

  public export
  data ErlFun2 : Type -> Type -> Type -> Type where
    MkErlFun2 : (a -> b -> ret) -> ErlFun2 a b ret

  public export
  data ErlFun3 : Type -> Type -> Type -> Type -> Type where
    MkErlFun3 : (a -> b -> c -> ret) -> ErlFun3 a b c ret

  public export
  data ErlFun4 : Type -> Type -> Type -> Type -> Type -> Type where
    MkErlFun4 : (a -> b -> c -> d -> ret) -> ErlFun4 a b c d ret

  public export
  data ErlFun5 : Type -> Type -> Type -> Type -> Type -> Type -> Type where
    MkErlFun5 : (a -> b -> c -> d -> e -> ret) -> ErlFun5 a b c d e ret

  public export
  data ErlIO0 : Type -> Type where
    MkErlIO0  : IO ret -> ErlIO0 ret

  public export
  data ErlIO1 : Type -> Type -> Type where
    MkErlIO1  : (a -> IO ret) -> ErlIO1 a ret

  public export
  data ErlIO2 : Type -> Type -> Type -> Type where
    MkErlIO2  : (a -> b -> IO ret) -> ErlIO2 a b ret

  public export
  data ErlIO3 : Type -> Type -> Type -> Type -> Type where
    MkErlIO3  : (a -> b -> c -> IO ret) -> ErlIO3 a b c ret

  public export
  data ErlIO4 : Type -> Type -> Type -> Type -> Type -> Type where
    MkErlIO4  : (a -> b -> c -> d -> IO ret) -> ErlIO4 a b c d ret

  public export
  data ErlIO5 : Type -> Type -> Type -> Type -> Type -> Type -> Type where
    MkErlIO5  : (a -> b -> c -> d -> e -> IO ret) -> ErlIO5 a b c d e ret


mutual
  public export
  data ErlType : Type -> Type where
    ETInt           : ErlType Int
    ETInteger       : ErlType Integer
    ETDouble        : ErlType Double
    ETString        : ErlType String
    ETChar          : ErlType Char

    ETUnit          : ErlType ()
    ETBool          : ErlType Bool
    ETList          : ErlType a => ErlType (List a)
    ETFun           : (ErlType a, ErlType b) => ErlType (a -> b) -- NOTE: These functions are curried in Erlang as well

    ETRaw           : ErlType (Raw a)     -- Can contain any Idris value
    ETErlTerm       : ErlType ErlTerm     -- Can contain any Erlang term

    -- Data types that bridge to native Erlang data types
    ETErlAtom       : ErlType ErlAtom
    ETErlBinary     : ErlType ErlBinary
    ETErlCharlist   : ErlType ErlCharlist
    ETErlList       : ErlTypes xs => ErlType (ErlList xs)
    ETErlMap        : ErlType ErlMap
    ETErlPid        : ErlType ErlPid
    ETErlRef        : ErlType ErlRef
    ETErlPort       : ErlType ErlPort
    ETErlTuple0     : ErlType ErlTuple0
    ETErlTuple1     : ErlTypes [a]                  => ErlType (ErlTuple1 a)
    ETErlTuple2     : ErlTypes [a, b]               => ErlType (ErlTuple2 a b)
    ETErlTuple3     : ErlTypes [a, b, c]            => ErlType (ErlTuple3 a b c)
    ETErlTuple4     : ErlTypes [a, b, c, d]         => ErlType (ErlTuple4 a b c d)
    ETErlTuple5     : ErlTypes [a, b, c, d, e]      => ErlType (ErlTuple5 a b c d e)
    ETErlFun0       : ErlTypes [ret]                => ErlType (ErlFun0 ret)
    ETErlFun1       : ErlTypes [a, ret]             => ErlType (ErlFun1 a ret)
    ETErlFun2       : ErlTypes [a, b, ret]          => ErlType (ErlFun2 a b ret)
    ETErlFun3       : ErlTypes [a, b, c, ret]       => ErlType (ErlFun3 a b c ret)
    ETErlFun4       : ErlTypes [a, b, c, d, ret]    => ErlType (ErlFun4 a b c d ret)
    ETErlFun5       : ErlTypes [a, b, c, d, e, ret] => ErlType (ErlFun5 a b c d e ret)
    ETErlIO0        : ErlTypes [ret]                => ErlType (ErlIO0 ret)
    ETErlIO1        : ErlTypes [a, ret]             => ErlType (ErlIO1 a ret)
    ETErlIO2        : ErlTypes [a, b, ret]          => ErlType (ErlIO2 a b ret)
    ETErlIO3        : ErlTypes [a, b, c, ret]       => ErlType (ErlIO3 a b c ret)
    ETErlIO4        : ErlTypes [a, b, c, d, ret]    => ErlType (ErlIO4 a b c d ret)
    ETErlIO5        : ErlTypes [a, b, c, d, e, ret] => ErlType (ErlIO5 a b c d e ret)

  public export
  data ErlTypes : List Type -> Type where
    ETErlTypesNil   : ErlTypes []
    ETErlTypesCons  : (ErlType x, ErlTypes xs) => ErlTypes (x :: xs)


namespace CaseExpr
  public export
  TypesToFunc : List Type -> Type -> Type
  TypesToFunc [] ret = ret
  TypesToFunc (x :: xs) ret = x -> TypesToFunc xs ret

  mutual
    public export
    data ErlMatcher : Type -> Type where
      MExact        : ErlType a => a -> (a -> b) -> ErlMatcher b
      MAny          : (ErlTerm -> a)      -> ErlMatcher a
      MInteger      : (Integer -> a)      -> ErlMatcher a
      MDouble       : (Double -> a)       -> ErlMatcher a
      MString       : (String -> a)       -> ErlMatcher a
      MErlAtom      : (ErlAtom -> a)      -> ErlMatcher a
      MErlBinary    : (ErlBinary -> a)    -> ErlMatcher a
      MErlCharlist  : (ErlCharlist -> a)  -> ErlMatcher a
      MErlMap       : (ErlMap -> a)       -> ErlMatcher a
      MErlPid       : (ErlPid -> a)       -> ErlMatcher a
      MErlRef       : (ErlRef -> a)       -> ErlMatcher a
      MErlPort      : (ErlPort -> a)      -> ErlMatcher a
      MErlList      : ErlMatchers ErlMatcher xs  -> TypesToFunc xs ret -> ErlMatcher ret
      MErlTuple     : ErlMatchers ErlMatcher xs  -> TypesToFunc xs ret -> ErlMatcher ret
      MErlMapSubset : ErlMatchers ErlMapEntry xs -> TypesToFunc xs ret -> ErlMatcher ret

    public export
    data ErlMatchers : (Type -> Type) -> List Type -> Type where
      Nil : ErlMatchers matcher []
      (::) : matcher x -> ErlMatchers matcher xs -> ErlMatchers matcher (x :: xs)

    export
    data ErlMapEntry : Type -> Type where
      MkErlMapEntry : ErlType key => key -> ErlMatcher value -> ErlMapEntry value

    -- TODO: Which priority?
    infix 3 :=

    export %inline
    (:=) : ErlType key => key -> ErlMatcher value -> ErlMapEntry value
    (:=) = MkErlMapEntry

  %extern
  export
  erlCase : a -> List (ErlMatcher a) -> ErlTerm -> a


namespace IO
  %extern prim__erlCall : (ret : Type) -> String -> ErlList xs -> (1 x : %World) -> IORes ret

  export %inline
  erlCall : (ret : Type) -> {auto ret_prf : ErlType ret} ->
            String ->
            ErlList xs -> {auto inp_prf : ErlTypes xs} ->
            IO ret
  erlCall ret fn args = primIO (prim__erlCall ret fn args)

  export
  erlUnsafeCast : (to : Type) -> {auto prf : ErlType to} -> ErlTerm -> to
  erlUnsafeCast to term = believe_me term


namespace Concurrency
  export
  erlSelf : IO ErlPid
  erlSelf = erlCall ErlPid "erlang:self" []

  export
  erlSpawn : IO () -> IO ErlPid
  erlSpawn action = erlCall ErlPid "erlang:spawn_link" [MkErlIO0 action]

  -- TODO: Support more receivers than just `ErlPid`
  export
  erlSend : ErlType a => ErlPid -> a -> IO ()
  erlSend receiver value = do
    erlCall ErlTerm "erlang:send" [receiver, value]
    pure ()

  -- TODO: Add proof that `ms` is in proper range: 0 - 16#FFFFFFFF (http://erlang.org/doc/reference_manual/expressions.html#receive)
  %extern
  export
  erlReceive : (ms : Int) -> a -> List (ErlMatcher a) -> IO a


namespace Maps
  export
  empty : ErlMap
  empty = unsafePerformIO $ erlCall ErlMap "maps:new" []

  -- TODO: Return type may not match the actual content
  export
  unsafeLookup : ErlType key => key -> (ret : Type) -> {auto prf : ErlType ret} -> ErlMap -> Maybe ret
  unsafeLookup key ty m = unsafePerformIO $ do
    result <- erlCall ErlTerm "maps:find" [key, m]
    pure $ erlCase Nothing [MErlTuple [MExact (MkErlAtom "ok") id, MAny id] (\ok, value => Just (erlUnsafeCast ty value))] result

  export
  insert : (ErlType key, ErlType value) => key -> value -> ErlMap -> ErlMap
  insert key value m = unsafePerformIO $ erlCall ErlMap "maps:put" [key, value, m]

  export
  delete : ErlType key => key -> ErlMap -> ErlMap
  delete key m = unsafePerformIO $ erlCall ErlMap "maps:remove" [key, m]

  size : ErlMap -> Integer
  size m = unsafePerformIO $ erlCall Integer "maps:size" [m]


----------
-- CAST --
----------

toErlTerm : ErlType a => a -> ErlTerm
toErlTerm x = believe_me x

-- Allow all supported Erlang types to be type erased
ErlType a => Cast a ErlTerm where
  cast x = toErlTerm x


Cast () ErlTuple0 where
  cast MkUnit = MkErlTuple0

Cast ErlTuple0 () where
  cast MkErlTuple0 = MkUnit


Cast Bool ErlAtom where
  cast True = MkErlAtom "true"
  cast False = MkErlAtom "false"


ErlType a => Cast (List a) (ErlList []) where
  cast [] = []

(ErlType a, Cast (List a) (ErlList as)) => Cast (List a) (ErlList (a :: as)) where
  cast (x :: xs) = (x :: cast xs)


----------
-- SHOW --
----------

showSep : String -> List String -> String
showSep sep [] = ""
showSep sep [x] = x
showSep sep (x :: xs) = x ++ sep ++ showSep sep xs


-- OPAQUE ERLANG TYPES
-- (Idris should not know its content)

Show ErlTerm where
  show _ = "<Erlang Term>"

Show ErlPid where
  show _ = "<Erlang Pid>"

Show ErlRef where
  show _ = "<Erlang Ref>"

Show ErlPort where
  show _ = "<Erlang Port>"


-- NORMAL ERLANG TYPES

Show ErlAtom where
  show (MkErlAtom x) = "'" ++ x ++ "'"

Show ErlBinary where
  show (MkErlBinary x) = "<<" ++ show x ++ ">>"

Show ErlCharlist where
  show (MkErlCharlist x) = show (erlUnsafeCast (List Int) (cast x))

Show (ErlList []) where
  show [] = "[]"

(Show x, Show (ErlList xs)) => Show (ErlList (x :: xs)) where
  show (x :: xs) = "[" ++ show x ++ " | " ++ show xs ++ "]"

Show ErlTuple0 where
  show MkErlTuple0 = "{}"

Show a => Show (ErlTuple1 a) where
  show (MkErlTuple1 x1) =
    "{" ++ showSep ", " [show x1] ++ "}"

(Show a, Show b) => Show (ErlTuple2 a b) where
  show (MkErlTuple2 x1 x2) =
    "{" ++ showSep ", " [show x1, show x2] ++ "}"

(Show a, Show b, Show c) => Show (ErlTuple3 a b c) where
  show (MkErlTuple3 x1 x2 x3) =
    "{" ++ showSep ", " [show x1, show x2, show x3] ++ "}"

(Show a, Show b, Show c, Show d) => Show (ErlTuple4 a b c d) where
  show (MkErlTuple4 x1 x2 x3 x4) =
    "{" ++ showSep ", " [show x1, show x2, show x3, show x4] ++ "}"

(Show a, Show b, Show c, Show d, Show e) => Show (ErlTuple5 a b c d e) where
  show (MkErlTuple5 x1 x2 x3 x4 x5) =
    "{" ++ showSep ", " [show x1, show x2, show x3, show x4, show x5] ++ "}"

Show ErlMap where
  show _ = "<Erlang Map>" -- TODO: Implement
