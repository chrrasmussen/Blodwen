module Main

import ErlangPrelude

%cg erlang """
get_map_empty() -> #{}.
get_map_ex1() -> #{<<"first">> => <<"ex1">>}.
get_map_ex2() -> #{<<"first">> => <<"ex2">>, <<"second">> => 42}.
get_pid() -> list_to_pid("<0.4.1>").
get_ref() -> list_to_ref("#Ref<0.4192537678.4073193475.71181>").
get_port() -> list_to_port("#Port<0.4>").
get_binary() -> <<"hello">>.
get_charlist() -> "hello".
"""

-- Wrappers around Erlang functions

mapEmpty : ErlMap
mapEmpty = unsafePerformIO $ erlCall ErlMap "get_map_empty" []

mapEx1 : ErlMap
mapEx1 = unsafePerformIO $ erlCall ErlMap "get_map_ex1" []

mapEx2 : ErlMap
mapEx2 = unsafePerformIO $ erlCall ErlMap "get_map_ex2" []

pidEx : ErlPid
pidEx = unsafePerformIO $ erlCall ErlPid "get_pid" []

refEx : ErlRef
refEx = unsafePerformIO $ erlCall ErlRef "get_ref" []

portEx : ErlPort
portEx = unsafePerformIO $ erlCall ErlPort "get_port" []

binaryEx : ErlBinary
binaryEx = unsafePerformIO $ erlCall ErlBinary "get_binary" []

charlistEx : ErlCharlist
charlistEx = unsafePerformIO $ erlCall ErlCharlist "get_charlist" []


-- Tests

testErlCase : IO ()
testErlCase = do
  putStrLn "testErlCase"
  putStrLn (erlCase "not found" [] (cast "any value"))
  putStrLn (erlCase "not found" [] (cast 1))
  putStrLn (erlCase "not found" [MInteger show] (cast "string is not an integer"))
  putStrLn (erlCase "not found" [MInteger show, MString id] (cast "string matches on second try"))
  printLn (erlCase (-1) [MInteger id] (cast 42))
  printLn (erlCase (-1) [MInteger id] (cast "string is not an integer"))
  printLn (erlCase Nothing [MString Just] (cast "val"))
  printLn (erlCase Nothing [MString Just] (cast 0))

testErlCaseInErlCase : IO ()
testErlCaseInErlCase = do
  putStrLn "testErlCaseInErlCase"
  putStrLn (erlCase "not found" [MErlTuple [MAny id] (\val => erlCase "inner not found" [MInteger show] val)] (cast (MkErlTuple1 42)))
  putStrLn (erlCase "not found" [MExact "find this" (\val => erlCase "inner not found" [MExact "find this" id] (cast val))] (cast "find this"))

testMExact : IO ()
testMExact = do
  putStrLn "testMExact"
  putStrLn (erlCase "not found" [MExact "match me" id] (cast "match me"))
  putStrLn (erlCase "not found" [MExact "match me" id] (cast "something else"))
  putStrLn (erlCase "not found" [MExact (MkErlAtom "ok") show] (cast (MkErlAtom "ok")))
  putStrLn (erlCase "not found" [MExact (MkErlAtom "ok") show] (cast "ok"))
  putStrLn (erlCase "not found" [MExact 42 show] (cast 42))
  putStrLn (erlCase "not found" [MExact 42 show] (cast (the Double 42)))

testMAny : IO ()
testMAny = do
  putStrLn "testMAny"
  putStrLn (erlCase "not found" [MAny (const "matched on string")] (cast "match me"))
  putStrLn (erlCase "not found" [MAny (const "matched on atom")] (cast (MkErlAtom "ok")))
  putStrLn (erlCase "not found" [MAny (const "matched on integer")] (cast 42))

testMInteger : IO ()
testMInteger = do
  putStrLn "testMInteger"
  putStrLn (erlCase "not found" [MInteger show] (cast 42))
  putStrLn (erlCase "not found" [MInteger show] (cast 0))
  putStrLn (erlCase "not found" [MInteger show] (cast (-42)))
  putStrLn (erlCase "not found" [MInteger show] (cast "string is not an integer"))
  putStrLn (erlCase "not found" [MInteger show] (cast (the Double 42)))

testMDouble : IO ()
testMDouble = do
  putStrLn "testMDouble"
  putStrLn (erlCase "not found" [MDouble show] (cast (the Double 42)))
  putStrLn (erlCase "not found" [MDouble show] (cast (the Double 0)))
  putStrLn (erlCase "not found" [MDouble show] (cast (the Double (-42))))
  putStrLn (erlCase "not found" [MDouble show] (cast "string is not an double"))
  putStrLn (erlCase "not found" [MDouble show] (cast 42))

testMString : IO ()
testMString = do
  putStrLn "testMString"
  putStrLn (erlCase "not found" [MString (++ "!")] (cast "found string"))
  putStrLn (erlCase "not found" [MString id] (cast 42))
  putStrLn (erlCase "not found" [MString id] (cast (MkErlAtom "ok")))

testMErlAtom : IO ()
testMErlAtom = do
  putStrLn "testMErlAtom"
  putStrLn (erlCase "not found" [MErlAtom show] (cast (MkErlAtom "ok")))
  putStrLn (erlCase "not found" [MErlAtom show] (cast (MkErlAtom "error")))
  putStrLn (erlCase "not found" [MErlAtom show] (cast "string is not an atom"))

testMErlBinary : IO ()
testMErlBinary = do
  putStrLn "testMErlBinary"
  putStrLn (erlCase "not found" [MErlBinary show] (cast binaryEx))
  putStrLn (erlCase "not found" [MErlBinary show] (cast 42))

testMErlCharlist : IO ()
testMErlCharlist = do
  putStrLn "testMErlCharlist"
  putStrLn (erlCase "not found" [MErlCharlist show] (cast charlistEx))
  putStrLn (erlCase "not found" [MErlCharlist show] (cast 42))

testMErlMap : IO ()
testMErlMap = do
  putStrLn "testMErlMap"
  putStrLn (erlCase "not found" [MErlMap (const "found map")] (cast mapEmpty))
  putStrLn (erlCase "not found" [MErlMap (const "found map")] (cast mapEx1))
  putStrLn (erlCase "not found" [MErlMap (const "found map")] (cast "not a map"))

testMErlPid : IO ()
testMErlPid = do
  putStrLn "testMErlPid"
  putStrLn (erlCase "not found" [MErlPid (const "found pid")] (cast pidEx))
  putStrLn (erlCase "not found" [MErlPid (const "found pid")] (cast "not a pid"))

testMErlRef : IO ()
testMErlRef = do
  putStrLn "testMErlRef"
  putStrLn (erlCase "not found" [MErlRef (const "found ref")] (cast refEx))
  putStrLn (erlCase "not found" [MErlRef (const "found ref")] (cast "not a ref"))

testMErlPort : IO ()
testMErlPort = do
  putStrLn "testMErlPort"
  putStrLn (erlCase "not found" [MErlPort (const "found port")] (cast portEx))
  putStrLn (erlCase "not found" [MErlPort (const "found port")] (cast "not a port"))

testMErlList : IO ()
testMErlList = do
  putStrLn "testMErlList"
  putStrLn (erlCase "not found" [MErlList [MString id] id] (cast $ (the (ErlList _) ["first item"])))
  putStrLn (erlCase "not found" [MErlList [MString id, MInteger show] (++)] (cast $ (the (ErlList _) ["first item", 42])))
  putStrLn (erlCase "not found" [MErlList [MString id] id] (cast $ (the (ErlList _) [])))
  putStrLn (erlCase "not found" [MErlList [MString id] id] (cast $ (the (ErlList _) ["a", "b"])))

testMErlTuple : IO ()
testMErlTuple = do
  putStrLn "testMErlTuple"
  putStrLn (erlCase "not found" [MErlTuple [] "is empty tuple"] (cast MkErlTuple0))
  putStrLn (erlCase "not found" [MErlTuple [] "is empty tuple"] (cast ()))
  putStrLn (erlCase "not found" [MErlTuple [] "is empty tuple"] (cast "not an empty tuple"))
  putStrLn (erlCase "not found" [MErlTuple [MAny (const "found any value")] id] (cast (MkErlTuple1 42)))
  putStrLn (erlCase "not found" [MErlTuple [MInteger show] id] (cast (MkErlTuple1 42)))
  putStrLn (erlCase "not found" [MErlTuple [MString id] id] (cast (MkErlTuple1 "string inside 1-element tuple")))
  putStrLn (erlCase "not found" [MErlTuple [MAny (const "found any value")] id] (cast 42))
  putStrLn (erlCase "not found" [MErlTuple [MString id, MString id] (\x, y => x ++ " & " ++ y)] (cast (MkErlTuple2 "first string" "second string")))
  putStrLn (erlCase "not found" [MErlTuple [MExact (MkErlAtom "ok") id, MInteger show] (\x, y => y)] (cast (MkErlTuple2 (MkErlAtom "ok") 42)))
  putStrLn (erlCase "not found" [MErlTuple [MExact (MkErlAtom "ok") id, MInteger show] (\x, y => y)] (cast (MkErlTuple3 (MkErlAtom "ok") 42 "too long tuple")))

testMErlMapSubset : IO ()
testMErlMapSubset = do
  putStrLn "testMErlMapSubset"
  putStrLn (erlCase "not found" [MErlMapSubset ["first" := MString id] id] (cast mapEx1))
  putStrLn (erlCase "not found" [MErlMapSubset ["first" := MString id] id] (cast mapEx2))
  putStrLn (erlCase "not found" [MErlMapSubset ["first" := MString id, "second" := MInteger id] (\first, second => first ++ " & " ++ show second)] (cast mapEx1))
  putStrLn (erlCase "not found" [MErlMapSubset ["first" := MString id, "second" := MInteger id] (\first, second => first ++ " & " ++ show second)] (cast mapEx2))

main : IO ()
main = do
  testErlCase
  testErlCaseInErlCase
  testMExact
  testMAny
  testMInteger
  testMDouble
  testMString
  testMErlAtom
  testMErlBinary
  testMErlCharlist
  testMErlMap
  testMErlPid
  testMErlRef
  testMErlPort
  testMErlList
  testMErlTuple
  testMErlMapSubset
